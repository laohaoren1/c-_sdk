# LinkerHand C++ SDK 架构设计文档

## 目录

1. [整体架构](#1-整体架构)
2. [生命周期管理](#2-生命周期管理)
3. [异步回调系统](#3-异步回调系统)
4. [线程安全设计](#4-线程安全设计)
5. [资源管理与清理](#5-资源管理与清理)
6. [数据流设计](#6-数据流设计)
7. [添加新设备示例](#7-添加新设备示例)

---

## 1. 整体架构

### 1.1 分层架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        用户应用层                                │
│                    (User Application)                           │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                        Facade 层                                 │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐            │
│  │   L6    │  │   L7    │  │   L10   │  │   L20   │  ...       │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                       Manager 层                                 │
│  ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌────────────┐   │
│  │   Angle    │ │   Force    │ │   Torque   │ │   Speed    │   │
│  │  Manager   │ │  Sensor    │ │  Manager   │ │  Manager   │   │
│  └────────────┘ └────────────┘ └────────────┘ └────────────┘   │
│  ┌────────────┐ ┌────────────┐ ┌────────────┐                  │
│  │Temperature │ │  Current   │ │   Fault    │                  │
│  │  Manager   │ │  Manager   │ │  Manager   │                  │
│  └────────────┘ └────────────┘ └────────────┘                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                       基础设施层                                 │
│  ┌──────────────────┐  ┌──────────────┐  ┌──────────────────┐  │
│  │ CANMessageDispatcher │  │  Lifecycle   │  │  IterableQueue   │  │
│  │   (CAN 通信调度)   │  │ (生命周期管理) │  │   (数据队列)     │  │
│  └──────────────────┘  └──────────────┘  └──────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                        系统层                                    │
│                   Linux SocketCAN API                           │
└─────────────────────────────────────────────────────────────────┘
```

### 1.2 核心组件职责

| 组件 | 职责 |
|------|------|
| **L6 (Facade)** | 统一入口，持有所有 Manager，管理共享生命周期 |
| **Manager** | 特定功能的数据采集与控制（角度、力传感器等） |
| **CANMessageDispatcher** | CAN 消息收发、订阅分发、线程池管理 |
| **Lifecycle** | 状态机管理，确保 close 后 API 行为一致 |
| **IterableQueue** | 线程安全的生产者-消费者队列，支持流式数据 |

---

## 2. 生命周期管理

### 2.1 设计目标

确保所有对外 API 在 `close()` 后具有一致的行为契约：
- **统一抛出 `StateError`**，而非未定义行为或不同类型的异常
- **阻塞操作立即唤醒**，不会等待超时
- **清理操作始终可执行**（如 `stop_streaming()`）

### 2.2 状态机设计

```
          ┌─────────────────────────────────────────┐
          │              Lifecycle                  │
          │  ┌───────┐    ┌─────────┐    ┌────────┐│
          │  │ Open  │───▶│ Closing │───▶│ Closed ││
          │  └───────┘    └─────────┘    └────────┘│
          │      │             │              │    │
          │      ▼             ▼              ▼    │
          │  允许操作      通知等待者      拒绝操作  │
          └─────────────────────────────────────────┘
```

### 2.3 共享 Lifecycle 模式

```cpp
// L6 持有共享的 Lifecycle，传递给所有 Manager
class L6 {
  std::shared_ptr<Lifecycle> lifecycle_;  // 共享状态

  AngleManager angle;        // 共享同一个 lifecycle_
  ForceSensorManager force;  // 共享同一个 lifecycle_
  // ...
};

// Manager 在每个公开方法入口检查状态
void AngleManager::set_angles(const std::array<int, 6>& angles) {
  lifecycle_->ensure_open();  // 非 Open 状态抛 StateError
  impl_->set_angles(angles);
}
```

### 2.4 API 行为矩阵

| API 方法 | Open 状态 | Closing/Closed 状态 |
|----------|-----------|---------------------|
| `set_angles()` | 正常执行 | 抛出 `StateError` |
| `get_*_blocking()` | 正常执行 | 立即抛出 `StateError` |
| `get_current_*()` | 正常执行 | 抛出 `StateError` |
| `stream()` | 正常执行 | 抛出 `StateError` |
| `stop_streaming()` | 正常执行 | **正常执行**（清理操作） |
| `close()` | 执行关闭 | 幂等，直接返回 |
| `is_closed()` | 返回 `false` | 返回 `true` |

---

## 3. 异步回调系统

### 3.1 问题背景

早期设计中，CAN 消息接收和回调处理在同一线程串行执行：

```
旧架构（存在阻塞问题）：
┌────────────────────────────────────────────┐
│  recv_thread:                              │
│    while (running) {                       │
│      msg = read();        // 接收消息      │
│      for (sub : subs) {                    │
│        sub.callback(msg); // 同步回调 ⚠️   │
│      }                                     │
│    }                                       │
└────────────────────────────────────────────┘
问题：一个慢回调会阻塞所有后续消息的接收和处理
```

### 3.2 线程池架构

```
新架构（异步非阻塞）：
┌─────────────────────────────────────────────────────────────┐
│                    CANMessageDispatcher                      │
│                                                              │
│  recv_thread（接收线程）：                                    │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  while (running) {                                      │ │
│  │    ① poll() 等待 CAN 消息                               │ │
│  │    ② read() 读取 CAN 帧                                 │ │
│  │    ③ for (sub : subscribers) {                          │ │
│  │         sub->queue.push_back(msg);  // 入队（纳秒级）    │ │
│  │         submit_task(drain(sub));    // 提交到线程池      │ │
│  │       }                                                  │ │
│  │    // 立即返回继续接收，不等待回调完成                     │ │
│  │  }                                                      │ │
│  └────────────────────────────────────────────────────────┘ │
│                              │                               │
│                              ▼                               │
│  ┌────────────────────────────────────────────────────────┐ │
│  │              Callback Thread Pool (2-4 workers)         │ │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐  │ │
│  │  │ Worker 1 │ │ Worker 2 │ │ Worker 3 │ │ Worker 4 │  │ │
│  │  │ drain(A) │ │ drain(B) │ │ drain(C) │ │  idle    │  │ │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘  │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘

特性：
- 每个订阅者有独立的消息队列（最大 64 条）
- 队列溢出时丢弃最旧消息并记录警告
- 一个慢回调只影响自己，不影响其他订阅者
```

### 3.3 订阅者状态管理

```cpp
struct SubscriberState {
  std::size_t id;
  Callback callback;

  std::atomic<bool> active{true};           // 是否活跃
  std::atomic<std::size_t> in_flight{0};    // 正在执行的回调数

  std::deque<CanMessage> pending_messages;  // 待处理消息队列
  bool worker_scheduled = false;            // 是否已调度 worker
  std::size_t dropped_messages = 0;         // 丢弃消息计数

  bool try_enter();      // 尝试进入回调（检查 active，增加 in_flight）
  void exit();           // 退出回调（减少 in_flight，通知等待者）
  void deactivate();     // 标记为非活跃
  void wait_for_idle();  // 等待所有回调完成
};
```

### 3.4 安全退订流程

```cpp
void CANMessageDispatcher::unsubscribe(std::size_t subscription_id) {
  // 1. 从订阅列表移除
  std::shared_ptr<SubscriberState> subscriber;
  {
    std::lock_guard<std::mutex> lock(subscribers_mutex_);
    auto it = find_subscriber(subscription_id);
    subscriber = *it;
    subscribers_.erase(it);
  }

  // 2. 标记为非活跃，阻止新回调进入
  subscriber->deactivate();

  // 3. 清空待处理队列
  {
    std::lock_guard<std::mutex> lock(subscriber->queue_mutex);
    subscriber->pending_messages.clear();
  }

  // 4. 避免死锁：不在自己的回调中等待自己
  const bool in_own_callback = tls_current_subscription_id == subscriber->id;
  if (in_own_callback) {
    return;  // 回调中退订自己，直接返回
  }

  // 5. 等待正在执行的回调完成
  subscriber->wait_for_idle();
}
```

---

## 4. 线程安全设计

### 4.1 双重检查模式

在关键操作前后进行状态检查，防止 TOCTOU（Time-of-Check to Time-of-Use）问题：

```cpp
void CANMessageDispatcher::send(const CanMessage& msg) {
  // 第一次检查（无锁快速路径）
  if (!running_.load(std::memory_order_acquire)) {
    throw StateError("CAN dispatcher is stopped");
  }

  std::lock_guard<std::mutex> lock(socket_mutex_);

  // 第二次检查（持锁确认）
  if (!running_.load(std::memory_order_acquire)) {
    throw StateError("CAN dispatcher is stopped");
  }

  // 安全执行写操作
  ::write(socket_fd_, &frame, sizeof(frame));
}
```

### 4.2 锁的层次结构

```
锁获取顺序（避免死锁）：
┌──────────────────────────────────────────────┐
│  subscribers_mutex_  (订阅者列表锁)           │
│       │                                      │
│       ▼                                      │
│  subscriber->queue_mutex  (单个订阅者队列锁)  │
│       │                                      │
│       ▼                                      │
│  subscriber->mutex  (订阅者状态锁)            │
│       │                                      │
│       ▼                                      │
│  socket_mutex_  (Socket 写锁)                │
└──────────────────────────────────────────────┘

规则：获取锁必须按此顺序，释放锁按相反顺序
```

### 4.3 原子操作使用

```cpp
// 状态标志使用 atomic，避免数据竞争
std::atomic<bool> running_{false};
std::atomic<bool> streaming_running_{false};

// 内存序选择
running_.store(true, std::memory_order_release);   // 写操作
running_.load(std::memory_order_acquire);          // 读操作
closed_.exchange(true, std::memory_order_acq_rel); // 读-改-写
```

---

## 5. 资源管理与清理

### 5.1 RAII 与析构顺序

```cpp
class L6 {
  // 成员声明顺序决定析构顺序（逆序析构）
  std::shared_ptr<Lifecycle> lifecycle_;  // 最后析构
  CANMessageDispatcher dispatcher_;       // 倒数第二

  AngleManager angle;         // 依赖 dispatcher_，先析构
  ForceSensorManager force;   // 依赖 dispatcher_，先析构
  // ...

  ~L6() {
    try {
      close();  // 显式清理，确保有序关闭
    } catch (...) {}
  }
};
```

### 5.2 关闭流程

```cpp
void L6::close() {
  // 1. 幂等检查
  if (lifecycle_->is_closed()) {
    return;
  }

  // 2. 停止所有流式数据（在 lifecycle 状态变更前）
  try {
    force_sensor.stop_streaming();
    angle.stop_streaming();
    torque.stop_streaming();
    temperature.stop_streaming();
    current.stop_streaming();
  } catch (...) {}

  // 3. 进入 Closing 状态，阻止新操作
  lifecycle_->begin_close();

  // 4. 通知所有等待者立即唤醒
  lifecycle_->notify_closing();

  // 5. 停止通信层
  try {
    dispatcher_.stop();
  } catch (...) {}

  // 6. 进入 Closed 终态
  lifecycle_->finish_close();
}
```

### 5.3 Manager 的 Pimpl 模式

```cpp
class AngleManager {
 public:
  AngleManager(uint32_t id, CANMessageDispatcher& d, std::shared_ptr<Lifecycle> lc);
  ~AngleManager();  // = default，自动析构 impl_

 private:
  struct Impl;                    // 前向声明
  std::unique_ptr<Impl> impl_;    // 实现细节隐藏
  std::shared_ptr<Lifecycle> lifecycle_;
};

// Impl 析构时自动清理
AngleManager::Impl::~Impl() {
  try { stop_streaming(); } catch (...) {}
  try { lifecycle->unsubscribe(subscription_id); } catch (...) {}
  dispatcher.unsubscribe(can_subscription_id);
}
```

---

## 6. 数据流设计

### 6.1 阻塞式数据获取

```cpp
AngleData get_angles_blocking(double timeout_ms) {
  // 1. 创建等待者对象
  auto waiter = std::make_shared<AngleWaiter>();
  {
    std::lock_guard<std::mutex> lock(waiters_mutex);
    waiters.push_back(waiter);
  }

  // 2. 发送数据请求（如果不在流式模式）
  if (!is_streaming) {
    send_sense_request();
  }

  // 3. 条件变量等待，支持超时和生命周期感知
  std::unique_lock<std::mutex> lock(waiter->mutex);
  bool ok = waiter->cv.wait_for(lock, timeout, [&] {
    return waiter->ready ||
           lifecycle->state() != LifecycleState::Open;  // 生命周期感知
  });

  // 4. 返回数据或抛出异常
  if (ok && waiter->data.has_value()) {
    return *waiter->data;
  }

  // 清理等待者
  remove_waiter(waiter);

  // 优先检查生命周期（close 时抛 StateError 而非 TimeoutError）
  lifecycle->ensure_open();
  throw TimeoutError("No data received within timeout");
}
```

### 6.2 流式数据获取

```
┌──────────────────────────────────────────────────────────────┐
│                        流式数据流程                           │
│                                                              │
│  stream() 调用                                               │
│       │                                                      │
│       ▼                                                      │
│  ┌─────────────────┐     ┌─────────────────┐                │
│  │ Streaming Thread│────▶│ IterableQueue   │                │
│  │ (定时发送请求)   │     │ (线程安全队列)   │                │
│  └─────────────────┘     └─────────────────┘                │
│                                 │                            │
│                                 ▼                            │
│                          用户迭代消费                         │
│                          for (data : queue)                  │
│                                                              │
│  stop_streaming() 或 close()                                 │
│       │                                                      │
│       ▼                                                      │
│  queue.close() → 迭代器抛出 StopIteration                    │
└──────────────────────────────────────────────────────────────┘
```

---

## 7. 添加新型号手示例

以添加一个新型号 `L10`（10 自由度灵巧手）为例，与 `l6` 目录同级。

### 7.1 目录结构

```
include/linkerhand/hand/
├── l6/                          # 现有 L6 手
│   ├── l6.hpp
│   ├── angle_manager.hpp
│   └── force_sensor_manager.hpp
└── l10/                         # 新增 L10 手
    ├── l10.hpp                  # Facade 类
    └── angle_manager.hpp        # 可复用或自定义的 Manager

src/hand/
├── l6/
│   ├── l6.cpp
│   └── angle_manager.cpp
├── l10/                         # 新增
│   ├── l10.cpp
│   └── angle_manager.cpp
└── common.hpp                   # 共享工具函数
```

### 7.2 Facade 类头文件

```cpp
// include/linkerhand/hand/l10/l10.hpp
#pragma once

#include <cstdint>
#include <memory>
#include <string>

#include "linkerhand/can_dispatcher.hpp"
#include "linkerhand/lifecycle.hpp"
#include "linkerhand/hand/l10/angle_manager.hpp"

namespace linkerhand::hand::l10 {

class L10 {
 private:
  std::shared_ptr<linkerhand::Lifecycle> lifecycle_;
  CANMessageDispatcher dispatcher_;
  std::uint32_t arbitration_id_ = 0x30;  // L10 特有的 CAN ID

 public:
  L10(const std::string& side,
      const std::string& interface_name,
      const std::string& interface_type = "socketcan");
  ~L10();

  L10(const L10&) = delete;
  L10& operator=(const L10&) = delete;

  // L10 特有的 Manager（10 自由度角度控制）
  AngleManager angle;

  void close();
  bool is_closed() const;
};

}  // namespace linkerhand::hand::l10
```

### 7.3 Facade 类实现

```cpp
// src/hand/l10/l10.cpp
#include "linkerhand/hand/l10/l10.hpp"

namespace linkerhand::hand::l10 {

L10::L10(const std::string& side,
         const std::string& interface_name,
         const std::string& interface_type)
    : lifecycle_(std::make_shared<linkerhand::Lifecycle>("L10")),
      dispatcher_(interface_name, interface_type),
      arbitration_id_(side == "right" ? 0x2F : 0x30),  // L10 的 CAN ID
      angle(arbitration_id_, dispatcher_, lifecycle_) {}

L10::~L10() {
  try {
    close();
  } catch (...) {}
}

void L10::close() {
  if (lifecycle_->is_closed()) {
    return;
  }

  // 1. 停止所有流式数据
  try {
    angle.stop_streaming();
  } catch (...) {}

  // 2. 进入 Closing 状态
  lifecycle_->begin_close();
  lifecycle_->notify_closing();

  // 3. 停止通信层
  try {
    dispatcher_.stop();
  } catch (...) {}

  // 4. 进入 Closed 状态
  lifecycle_->finish_close();
}

bool L10::is_closed() const {
  return lifecycle_->is_closed();
}

}  // namespace linkerhand::hand::l10
```

### 7.4 自定义 Manager（协议不同时）

如果 L10 的角度控制协议与 L6 不同，需要自定义 Manager：

```cpp
// include/linkerhand/hand/l10/angle_manager.hpp
#pragma once

#include <array>
#include <cstdint>
#include <memory>
#include <optional>

#include "linkerhand/can_dispatcher.hpp"
#include "linkerhand/iterable_queue.hpp"
#include "linkerhand/lifecycle.hpp"

namespace linkerhand::hand::l10 {

// L10 是 10 自由度，数据结构不同于 L6
struct AngleData {
  std::array<int, 10> angles{};  // 10 个关节角度
  double timestamp = 0.0;
};

class AngleManager {
 public:
  AngleManager(std::uint32_t arbitration_id, CANMessageDispatcher& dispatcher);
  AngleManager(
      std::uint32_t arbitration_id,
      CANMessageDispatcher& dispatcher,
      std::shared_ptr<linkerhand::Lifecycle> lifecycle);
  ~AngleManager();

  AngleManager(const AngleManager&) = delete;
  AngleManager& operator=(const AngleManager&) = delete;

  // L10 特有：10 个角度
  void set_angles(const std::array<int, 10>& angles);

  AngleData get_angles_blocking(double timeout_ms = 100);
  std::optional<AngleData> get_current_angles() const;

  IterableQueue<AngleData> stream(double interval_ms = 100, std::size_t maxsize = 100);
  void stop_streaming();

 private:
  struct Impl;
  std::unique_ptr<Impl> impl_;
  std::shared_ptr<linkerhand::Lifecycle> lifecycle_;
};

}  // namespace linkerhand::hand::l10
```

### 7.5 复用现有 Manager（协议相同时）

如果 L10 的某个功能与 L6 协议完全相同，可以直接复用：

```cpp
// 方式一：使用类型别名
// include/linkerhand/hand/l10/l10.hpp
#include "linkerhand/hand/l6/force_sensor_manager.hpp"

namespace linkerhand::hand::l10 {

// 直接复用 L6 的 ForceSensorManager
using ForceSensorManager = linkerhand::hand::l6::ForceSensorManager;

class L10 {
 public:
  AngleManager angle;           // L10 自定义（10 自由度）
  ForceSensorManager force;     // 复用 L6 的
};

}  // namespace linkerhand::hand::l10
```

```cpp
// 方式二：继承并扩展
// include/linkerhand/hand/l10/angle_manager.hpp
#include "linkerhand/hand/l6/angle_manager.hpp"

namespace linkerhand::hand::l10 {

class AngleManager : public linkerhand::hand::l6::AngleManager {
 public:
  using Base = linkerhand::hand::l6::AngleManager;
  using Base::Base;  // 继承构造函数

  // 添加 L10 特有的方法
  void set_finger_spread(int spread);
};

}  // namespace linkerhand::hand::l10
```

### 7.6 注册到统一入口（可选）

```cpp
// include/linkerhand/linkerhand.hpp
#pragma once

#include "linkerhand/hand/l6/l6.hpp"
#include "linkerhand/hand/l10/l10.hpp"

namespace linkerhand {

// 便捷别名
using L6 = hand::l6::L6;
using L10 = hand::l10::L10;

}  // namespace linkerhand
```

### 7.7 使用示例

```cpp
#include "linkerhand/linkerhand.hpp"

int main() {
  // 使用 L6（6 自由度）
  linkerhand::L6 hand_l6("left", "can0");
  hand_l6.angle.set_angles({100, 100, 100, 100, 100, 100});

  // 使用 L10（10 自由度）
  linkerhand::L10 hand_l10("right", "can1");
  hand_l10.angle.set_angles({100, 100, 100, 100, 100, 100, 100, 100, 100, 100});

  // 关闭
  hand_l6.close();
  hand_l10.close();

  return 0;
}
```

### 7.8 关键要点总结

| 要点 | 说明 |
|------|------|
| **独立命名空间** | `linkerhand::hand::l10`，与 `l6` 隔离 |
| **复用基础设施** | 共享 `Lifecycle`、`CANMessageDispatcher`、`IterableQueue` |
| **自定义协议参数** | CAN ID、命令字节、数据结构可按需调整 |
| **Manager 复用策略** | 协议相同用类型别名，部分相同用继承，完全不同则重写 |
| **保持一致的生命周期契约** | 新设备必须遵循相同的 close 后抛 StateError 行为 |
| **统一入口注册** | 在 `linkerhand.hpp` 中暴露，方便用户使用 |
